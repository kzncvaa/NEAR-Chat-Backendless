
  /*******************************************************************
  * NEAR.js
  * Generated by Backendless Corp.
  ********************************************************************/
		
const Utils = {
  isObject : obj => obj === Object(obj),
  isString : obj => Object.prototype.toString.call(obj).slice(8, -1) === 'String',
  isNumber : obj => Object.prototype.toString.call(obj).slice(8, -1) === 'Number',
  isBoolean: obj => Object.prototype.toString.call(obj).slice(8, -1) === 'Boolean',
  isDate   : obj => Object.prototype.toString.call(obj).slice(8, -1) === 'Date'
}

Backendless.APIServices.NEAR = {
  Login(account_id,callback_url,network) {   
    if (!Utils.isString(account_id)) {
      throw new Error('Invalid value for argument "account_id". Must be string value')
    }
      
    if (!Utils.isString(callback_url)) {
      throw new Error('Invalid value for argument "callback_url". Must be string value')
    }
      
    if (!Utils.isString(network)) {
      throw new Error('Invalid value for argument "network". Must be string value')
    }
    
    const args = {
      account_id: account_id,
        callback_url: callback_url,
        network: network
    }
      
    return Backendless.APIServices.invoke('NEAR', 'Login', args)
  },

  getInfoByTransaction(transactionHashes,username) {   
    if (!Utils.isString(transactionHashes)) {
      throw new Error('Invalid value for argument "transactionHashes". Must be string value')
    }
      
    if (!Utils.isString(username)) {
      throw new Error('Invalid value for argument "username". Must be string value')
    }
    
    const args = {
      transactionHashes: transactionHashes,
        username: username
    }
      
    return Backendless.APIServices.invoke('NEAR', 'getInfoByTransaction', args)
  },

  getPrivateKey(seed_phrase) {   
    if (!Utils.isString(seed_phrase)) {
      throw new Error('Invalid value for argument "seed_phrase". Must be string value')
    }
    
    const args = seed_phrase
    return Backendless.APIServices.invoke('NEAR', 'getPrivateKey', args)
  },

  Balance(account_id) {   
    if (!Utils.isString(account_id)) {
      throw new Error('Invalid value for argument "account_id". Must be string value')
    }
    
    const args = account_id
    return Backendless.APIServices.invoke('NEAR', 'Balance', args)
  },

  view() { 
    const args = null
      
    return Backendless.APIServices.invoke('NEAR', 'view', args)
  },

  sendMessage(account_id,private_key,text) {   
    if (!Utils.isString(account_id)) {
      throw new Error('Invalid value for argument "account_id". Must be string value')
    }
      
    if (!Utils.isString(private_key)) {
      throw new Error('Invalid value for argument "private_key". Must be string value')
    }
      
    if (!Utils.isString(text)) {
      throw new Error('Invalid value for argument "text". Must be string value')
    }
    
    const args = {
      account_id: account_id,
        private_key: private_key,
        text: text
    }
      
    return Backendless.APIServices.invoke('NEAR', 'sendMessage', args)
  },

  transaction(sender_id,receiver_id,deposit,callback_url,network,message) {   
    if (!Utils.isString(sender_id)) {
      throw new Error('Invalid value for argument "sender_id". Must be string value')
    }
      
    if (!Utils.isString(receiver_id)) {
      throw new Error('Invalid value for argument "receiver_id". Must be string value')
    }
      
    if (!Utils.isString(deposit)) {
      throw new Error('Invalid value for argument "deposit". Must be string value')
    }
      
    if (!Utils.isString(callback_url)) {
      throw new Error('Invalid value for argument "callback_url". Must be string value')
    }
      
    if (!Utils.isString(network)) {
      throw new Error('Invalid value for argument "network". Must be string value')
    }
      
    if (!Utils.isString(message)) {
      throw new Error('Invalid value for argument "message". Must be string value')
    }
    
    const args = {
      sender_id: sender_id,
        receiver_id: receiver_id,
        deposit: deposit,
        callback_url: callback_url,
        network: network,
        message: message
    }
      
    return Backendless.APIServices.invoke('NEAR', 'transaction', args)
  },

  deployContract(account_id,private_key) {   
    if (!Utils.isString(account_id)) {
      throw new Error('Invalid value for argument "account_id". Must be string value')
    }
      
    if (!Utils.isString(private_key)) {
      throw new Error('Invalid value for argument "private_key". Must be string value')
    }
    
    const args = {
      account_id: account_id,
        private_key: private_key
    }
      
    return Backendless.APIServices.invoke('NEAR', 'deployContract', args)
  },

  mintNFT(token_id,metadata,account_id,private_key) {   
    if (!Utils.isString(token_id)) {
      throw new Error('Invalid value for argument "token_id". Must be string value')
    }
      
    if (!Utils.isString(metadata)) {
      throw new Error('Invalid value for argument "metadata". Must be string value')
    }
      
    if (!Utils.isString(account_id)) {
      throw new Error('Invalid value for argument "account_id". Must be string value')
    }
      
    if (!Utils.isString(private_key)) {
      throw new Error('Invalid value for argument "private_key". Must be string value')
    }
    
    const args = {
      token_id: token_id,
        metadata: metadata,
        account_id: account_id,
        private_key: private_key
    }
      
    return Backendless.APIServices.invoke('NEAR', 'mintNFT', args)
  },

  transferNFT(token_id,receiver_id,enforce_owner_id,memo,enforce_private_key,contract) {   
    if (!Utils.isString(token_id)) {
      throw new Error('Invalid value for argument "token_id". Must be string value')
    }
      
    if (!Utils.isString(receiver_id)) {
      throw new Error('Invalid value for argument "receiver_id". Must be string value')
    }
      
    if (!Utils.isString(enforce_owner_id)) {
      throw new Error('Invalid value for argument "enforce_owner_id". Must be string value')
    }
      
    if (!Utils.isString(memo)) {
      throw new Error('Invalid value for argument "memo". Must be string value')
    }
      
    if (!Utils.isString(enforce_private_key)) {
      throw new Error('Invalid value for argument "enforce_private_key". Must be string value')
    }
      
    if (!Utils.isString(contract)) {
      throw new Error('Invalid value for argument "contract". Must be string value')
    }
    
    const args = {
      token_id: token_id,
        receiver_id: receiver_id,
        enforce_owner_id: enforce_owner_id,
        memo: memo,
        enforce_private_key: enforce_private_key,
        contract: contract
    }
      
    return Backendless.APIServices.invoke('NEAR', 'transferNFT', args)
  }
}
